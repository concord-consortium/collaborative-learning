# CLUE's usage of webpack's splitChunks

The first thing to know is that even with splitChunks disabled, webpack will generate multiple chunks based on the current CLUE code. This is because CLUE uses dynamic imports for the Tiles and SharedModels, see [register-tools.ts](../src/register-tools.ts). 

However with splitChunks disabled (`splitChunks: false`), these resulting chunks will have duplicate code in them. This is because webpack will bundle every dependency with these dynamic chunks that doesn't already exist in the main bundle. So for example react-tippy and popper are used by the tiles but not the main CLUE code, so they will be duplicated in every tile's chunk.

Without any configuration webpack has splitChunks enabled with a default configuration. This default configuration is described in the documentation of the [SplitChunks Plugin](https://webpack.js.org/plugins/split-chunks-plugin/). However this documentation is very confusing.

We customize this default configuration slightly to change the file names and reduce the number of files to make them easier to track. The list of output javascript files currently looks like:
| size | name    |
| ---- | ------- |
| 2.5M | index.39b65255dc94edb5e87d.js |
| 886K | Geometry.9d20456c8fad2c67158c.js |
| 765K | Dataflow.a1d8573c2e0b84833b3a.js |
| 467K | common-Diagram-SharedVariables-859.f9c52179.js |
|  84K | SharedVariables.b4653a3e15d7f411b055.js |
|  82K | Table.2b768b901eebb110c3cd.js |
|  51K | common-DataCard-SharedVariables-Drawing-Geometry-Image-Table-Text-964.1c62df70.js |
|  33K | common-SharedVariables-Drawing-306.51aea140.js |
|  26K | common-Dataflow-Geometry-935.0bd31c83.js |
|  23K | Drawing.43904638147c445275c9.js |
|  16K | Text.f598906f6e85ad13d3ed.js |
|  16K | DataCard.0f0dcb19c01456654c10.js |
|  15K | Image.82881f51f9085515988f.js |
| 4.3K | Diagram.ad8a13bc06b34c255002.js |
| 1.2K | Starter.b26bfa75279716da1565.js |
| 266B | SharedDataSet.981197942b12c6c28a6f.js |

This output is the result of several things in different places:
1. in `register-tools.ts` the chunk name is specified for each of the imports. This is where the names like Image, Drawing, and Text come from.
2. in `webpack.config.js` there is a  `output.chunkName: '[name].[contenthash].js'` settings. This is where the names like `Starter.b26bfa75279716da1565.js` come from. Without this the initial chunks would have names based on the top level `output.name` configuration.
3. in `webpack.config.js` there is an `optimization.splitChunks.filename` function that uses metadata provided by webpack to customize the names of the chunks generated by SplitChunks. This is where the names like `common-Dataflow-Geometry-935.0bd31c83.js` come from. Without this setting that file name would be `935.[contenthash].js`. This is because it would use `output.chunkName` setting.
4. in `webpack.config.js` there is an `optimization.splitChunks.minChunks: 2` setting which says to only generate a new chunk if it is depended on by at least two other initial chunks. Without this setting webpack would split several files into two. For example `Dataflow.a1d8573c2e0b84833b3a.js(765K)` would be split into `common-Dataflow-55.a5319196.js(525K)` and `Dataflow.7bdb8e82be5899e02a25.js(240K)`. This splitting in two probably would load faster because the download can be done in parallel, however this makes it harder to keep track of the size of each tile's code.

## Inspecting the chunks

When changing the configuration or trying to understand why a chunk changed, it is useful to inspect what is in each chunk. There is a nice visualization tool that helps with this. You can run it with

```
> npm run stats
> npx webpack-bundle-analyzer stats.json dist
```

If you want to generate a markdown table like the one above of the javascript chunks you can use this command: `ls -lhS dist/*.js | awk '{print "|", $5, "|", $9, "|"}'`

If you are changing the webpack configuration, it is useful to check the generated index.html after a build. This will show which chunks webpack has decided need to be loaded when the page loads. If a chunk isn't listed there, then it should be dynamically loaded when the tile is loaded.

## `splitChunks.cacheGroups` and `splitChunks.cacheGroups.[group].name` config

One of the most confusing things about splitChunks are the cacheGroups and the name property. We are not configuring these groups or the name is property, but we used to.

The cacheGroups are a way to customize the splitChunks config on a per module basis. If the module matches the test in the cacheGroup then the settings of that cacheGroup will apply. SplitChunks provides two default groups which we are not customizing. See below for more info about these default groups.

The `name` property determines the name of the generated chunk the module will go into. If you use a fixed string like `name: 'common'` then every module will go into a single bundle/chunk called "common". So this name is not just the name of the output file, it actually determines how the chunks are split. In our case, we want webpack to figure out the best place to put each of the modules. This allows webpack to avoid duplicates and optimize sizes.

## The filename function

The filename function currently being used is
```
filename: (pathData) => {
  const groupsNames = [...pathData.chunk._groups].map(group => group.options?.name);
  return `common-${groupsNames.join('-')}-[name].[chunkhash:8].js`;
},
```

This function was created by inspecting the `pathData`. This `pathData` is not documented by webpack as far as I found. I inspected it by adding console logs inside of the filename function like: `console.log("filename", pathData)`. Note that you need to run `npm run webpack:build` and not `npm run stats` because stats will eat the console log and put it in the `stats.json` file.  Node will only print a few levels of an object with a console log like that. So to dig further you need to reference parts of it directly. For example:

```
console.log("vendor filename", pathData.chunk.id, 
    [...pathData.chunk._groups].map(group => group.options?.name), 
    [...pathData.chunk._groups].map(group => group.chunks));
```

Note: some of the documentation implies the default filename will include several parts that looks similar to what our current filename function creates. However I could not find a way to get webpack to use that default filename.

## Default cacheGroups

The webpack documentation implies that you can override parts of the default cacheGroups (`default` and `defaultVendors`). But this doesn't work as expected. According to the documentation these groups are defined as:

```
defaultVendors: {
  test: /[\\/]node_modules[\\/]/,
  priority: -10,
  reuseExistingChunk: true,
},
default: {
  minChunks: 2,
  priority: -20,
  reuseExistingChunk: true,
},
```

If you try something simple like
```
defaultVendors: {}
```
You will get a completely different set of output files. If you use the documented defaults then you get the same set of output files. I did not experiment to find out if any of the default properties are merged or if none of them are. So if you want to customize these groups you should either specify all the default properties or experiment to see which ones are not necessary.
