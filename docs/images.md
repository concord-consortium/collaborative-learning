# Image Storage in CLUE

## Introduction

Image storage in CLUE has a long and tortuous history. This document documents some of that history and attempts to explain where we are now and give some sense of how we ended up here.

CLUE supports images in three types of tiles: Image tiles can show a single image; Geometry tiles can have a single image as a background for the coordinate system; and Drawing tiles can have one or more image objects. The earliest images supported by CLUE were the images embedded in the curriculum content, which were instantiated into image tiles and referenced the underlying curriculum image by relative url, e.g. `curriculum/stretching-and-shrinking/images/inscriptions3_450w.png`. Since the curriculum content along with all of its assets are (then and currently) built into the application, these images are straightforward to work with in the code. (These relative urls will need to be accounted for if/when we implement the ability to store authored curriculum content outside of the application, but that's a topic for another day.) Static images in curriculum only get you so far, however, and so fairly early on we added the ability for users to upload images to the image tile. To do so, however, we needed to find a place to store the uploaded images, which is where the rest of our saga begins.

## Firebase Storage

The first approach to storing uploaded images was to use Firebase Storage (aka [Cloud Storage for Firebase](https://firebase.google.com/docs/storage/)). This seemed like a fairly natural fit as it's designed for storing assets like photos and videos and is in the same product family as the [Firebase Realtime Database](https://firebase.google.com/docs/database/) which CLUE was/is using for its other storage needs. One of the things that makes Firebase Storage attractive for assets like images and videos is that it provides the ability to retrieve a download url that can be used directly as the `src` of an image tag, for instance. And so CLUE implemented an image storage system based on Firebase Storage and used it for a while until it became known that the download url provided by the `getDownloadUrl()` function is a truly public url with no security attached to it whatsoever. The returned url has long difficult-to-guess hash-like components, but to the extent that there's any security at all, it's security by obscurity. Anyone can access the image at that url if they were to get hold of the url, but at least they'd have a hard time guessing the url. After some consideration, however, it was decided that security-by-obscurity was not sufficient for use with student data and it was further determined that Firebase Storage didn't then (and may not to this day as I write this, according to [this issue](https://github.com/firebase/firebase-js-sdk/issues/76)) have a good solution for accessing images stored there in a secure manner. Maybe there would have been a way to access the image data via SDK rather than via `getDownloadUrl()` (possibly via firebase function) but at that point the decision was made to look for another storage model "and so with tears in our eyes we drove off into the sunset looking for another place to ~~put the garbage~~ store the images." (With apologies to Arlo Guthrie's [Alice's Restaurant](https://en.wikipedia.org/wiki/Alice%27s_Restaurant).)

A number of possibilities were discussed, e.g. Firestore (documents limited to 1MB) and AWS S3 storage, but they all seemed like a heavy lift, and possibly would require writing one or more cloud functions with which we didn't have much experience at that time, and so ultimately it was decided that the path of least resistance was to store the image data in our existing firebase realtime database as client-accessible base64-encoded strings.

## Firebase Realtime Database

Base64-encoding binary data is inefficient in that it can bloat the size of the asset by ~30%. But we already knew how to store and retrieve data from the realtime database and we already had a security model in place that could be applied to the image data and so we went ahead and re-implemented the image storage/retrieval code to target the realtime database. The realtime database has a fairly crude security model based on access to everything at and below particular folders/directories. Given the need to share data between arbitrary students (e.g. the four-up view), our implementation of the security model limits access to the data within a given class to members of that class, but doesn't restrict access more granularly than the class level. But this was fine for our purposes, as there were no plans for any form of sharing beyond a single class at that time and so image data for all images uploaded for a given class are stored in a top-level `images` folder within the folder for that class.

One other wrinkle is that we were making this transition at a time when there were active users in classrooms and so we had to have a migration strategy for dealing with legacy images that had been stored in Firebase Storage. As part of that strategy we developed the `ImageMap` MST model, which is responsible for storing and retrieving images to/from the various places that images can be stored and caching the image data so that any given image isn't downloaded more than necessary. The `ImageMap` implements a plugin-like model in which independent `ImageHandler`s are responsible for handling images of a particular type and the `ImageMap` is responsible for directing storage/retrieval requests to the appropriate `ImageHandler`. As of this writing the available image handlers are:

|Name|Description|Example References|
|----|-----------|------------------|
|`externalUrl`|remote images referenced by external url|standard image url|
|`localAssets`|remote images referenced by relative url, e.g. curriculum images|`curriculum/stretching-and-shrinking/images/inscriptions3_450w.png`|
|`firebaseStorage`|images stored in Firebase Storage|`https://firebasestorage.googleapis.com/path/to/image`|
|`firebaseRealTimeDB`|images stored in the Firebase Realtime Database|`ccimg://imageKey`, `ccimg://fbrtdb.concord.org/imageKey`, `ccimg://fbrtdb.concord.org/classHash/imageKey`|

Given that most of these take the form of a url, when adding support for images stored in the firebase realtime database we adopted an id in the form of a faux url (`ccimg://fbrtdb.concord.org/imageKey`) which was later expanded to a canonical form that includes class information (`ccimg://fbrtdb.concord.org/classHash/imageKey`). The `ImageMap` and its handlers automatically migrate images stored in firebase storage to the realtime database and convert references to the appropriate format when such images are accessed.

All of this worked fine until we decided to provide teachers with the ability to publish documents as supports that could be viewed by students in any of their classes.

## Multi-class Support Publications

As mentioned above, the cardinal rule of security in our implementation of the firebase realtime database is that access is restricted to those within a single class. Firebase security rules are used to prevent extra-class access at the database level, i.e. there's no way for a browser client to directly access data stored within the confines of another class. Therefore, to implement publication of multi-class supports, CLUE took its first foray into Google's [Cloud Firestore](https://firebase.google.com/docs/firestore/). Among its many features, Firestore has a more flexible security model and more powerful query capabilities. By publishing supports as Firestore documents, we were able to take advantage of both of these to limit access to members of any of a teacher's classes and then to efficiently query for such multi-class supports from any class.

This worked perfectly for access to the contents of the published support document, but once again images presented an additional wrinkle. As described previously, image data is stored separately from the document content; only references to the image data are stored with the document. This makes sense as there can be many references to a single image and we wouldn't want to have to copy the image data every time. While the additional features of Firestore could be leveraged to provide the fine-grained access required for the support documents, that wouldn't work for the image data which is still stored in the realtime database. To provide access to the image data itself we developed a cloud function which enforced a security model in which clients that had access to a particular support document (via firestore rules) would also be allowed to access image data referenced by those supports, _as long as the code was able to recognize that the client was requesting access to the image data in the context of a multi-class support and that the requested image data resided in the same class as the document being published_. (Google cloud functions are not subject to the same security limitations as web clients and so this implementation worked to provide access to images within support documents published to multiple classes.)

Fairly soon thereafter, however, it became apparent that limiting image access to situations in which the access came from the context of a multi-class support was insufficient. Students and teachers regularly copy images from curriculum or support documents to their own documents. Teachers have been known to publish a support with images, copy those images to a document in another class, and then publish a new support with these copied images such that the image data no longer resided in the same class as the document being published. In each of these cases the code no longer recognizes the requested image access as coming from a multi-class support document and/or the requested image data is not available in the class assumed by the cloud function.

For implementation reasons, the problems presented by students copying images into their own documents were mitigated somewhat by the caching model provided by the `ImageMap`. The situation in which this arose most acutely was in a class where the teacher was using published supports essentially as curriculum. Students would copy images from these supports into their own documents and then later they would open up their documents and the initial request for the image data would fail -- it wasn't coming from the context of a multi-class support and so the cross-class access request would fail. But then later if that same student opened up the support document that represented their curriculum, the image access would succeed. At that point, the `ImageMap` cached the association between the image id/url and its image data so any subsequent request for that image, e.g. to redraw the document in which the image access initially failed, would successfully retrieve the image data. As such, these initial failures would appear to magically fix themselves, possibly even before the user noticed a problem beyond an initial delay. (_We_ noticed, however, as each such initial failed access resulted in a Rollbar error.)

## Multi-class Images

As mentioned above the prior implementation worked when two simplifying assumptions were true: (a) the image data resided in the same class as the document that was published as a support; and (b) the code could successfully determine whether an image was being requested in the context of a published multi-class support. Unfortunately, the fact that users were free to copy images from supports into other documents meant that (b) could sometimes be violated; and the fact that teachers could copy images into documents in other classes and publish those meant that (a) was not completely reliable either.

To fix these issues once and for all, we need to make sure that (1) image data can always be found, regardless of its relation (or lack thereof) to the document within which it was originally published; and (2) we can always tell whether an image has been shared/published as part of a support regardless of the context in which the image reference is encountered. In other words, publishing a support implicitly publishes all of the images within it as independent entities. These were accomplished in the following steps:

1. Add class hash to image urls ([PR #1171](https://github.com/concord-consortium/collaborative-learning/pull/1171))
  - >This is step one in improving our image support and extending it to better handle multi-class image access via publication of multi-class supports. The root cause of some of the complexities in handling multi-class images is that historically image ids/urls have included only the firebase-generated key, which doesn't provide any indication of _where_ within firebase the image data might be found. We can't fix this problem historically without taking on an epic migration of all existing content. We can, however, address the problem moving forward by including the class hash in the id/url we use to refer to newly uploaded images. This will provide a straightforward means of determining whether access to any particular image requires multi-class permissions and the `getImageData()` firebase function or not.
2. Add `update-supports-images` script ([PR #1174](https://github.com/concord-consortium/collaborative-learning/pull/1174))
  - >This is step two in properly supporting multi-class images referenced from published multi-class supports. The fundamental limitation of the prior design is that while individual supports are published to firestore with rules for which classes should have access to those supports, image references in the content of those supports don't contain enough information to find the original images in cases in which the image data does not reside in the same class context as the document from which the support was published. This can happen either because teachers copy images from one support to another document in another class and then republish (the cause of the most recent issues encountered by some teachers) or because students copy images from published supports to their own documents in another class (the original scenario in which this problem was encountered).
  - >The fix is to explicitly represent each image referenced by a multi-class support in a new firestore `mcimages` collection which contains enough information to determine which classes should have access to the image as well as the ultimate location of the image data. The script in this PR processes the previously published multi-class supports to identify all relevant image references and creates the appropriate entries in the `mcimages` collection. Along the way, we also add entries to a firestore `images` collection which maps the locations of previously published images to the ultimate location of their image data, i.e. it allows us to fix image references in previously published supports.
3. Add `getImageData_v1` firebase function for retrieving image data ([PR #1176](https://github.com/concord-consortium/collaborative-learning/pull/1176))
  - >This is step three of the work to support multi-class images in multi-class supports. In [part two](https://github.com/concord-consortium/collaborative-learning/pull/1174) we designed the firestore schema and implemented a script to migrate existing published supports to the new format. With this PR, we implement the firebase function that retrieves the image data making use of the new firestore collections where appropriate.
4. Add `publishSupport()` firebase function ([PR #1180](https://github.com/concord-consortium/collaborative-learning/pull/1180))
  - >This is the final piece of the epic journey to support multi-class access to images published to multi-class supports and then potentially copied from there. In this piece, a new `publishSupport()` firebase function writes the multi-class support document to firestore (like before), but it also (a) canonicalizes image url references in the content so that image references copied from these multi-class supports will contain their class information and (b) writes a multi-class image entry to firestore for each image referenced in the support so that downstream clients will be able to determine which images have been published to which classes even after the image has been copied into another user context. For support of legacy images published as part of earlier multi-class supports, the new `publishSupport()` function consults the firestore `images` collection which maps legacy image url references to their correct locations and was constructed by the `update-supports-images` script implemented in step one of this epic.

## How getImageData looks up an image

This is an alternative way to look at the information above. The `getImageData` firebase function is how students and teachers can access images that are outside of their current class. Looking at this function's logic determines who can access which images.

1. It validates that the context param it is passed matches the auth info in the JWT that was passed in the header. This includes the portal, userId, and classHash (context_id).

2. The url param has to match the ccimg url pattern and have an imageKey. The url param might optionally have a classHash in it.

3. If the user's classHash (from the auth info) matches the image's classHash then the image data is returned from: `${classPath}/images/${imageKey}`.

4. 4 different imageClassPaths are searched for at the same time:

    a. if the imageClassHash wasn't set (a legacyURL), the users classPath is attempted to be used. If there is an image at that path it will be used.

    b. if the user is a teacher with a classHash and a network, then firestore is searched for class document with the imageClassHash and network of the teachers' network. If one is found then path is constructed as `${classPath.replace(userClassPath,imageClassHash)}}/images/${imageKey}`

    c. if there is mcimages doc with a matching legacyUrl and userClassHash is in the classes array of the mcimages doc, then the first classPath from these matching mcimages docs is used. This would apply to students or teachers where the image has been published to their current class. **Note** currently these mcimages docs are only created during a multi-class publish. If a teacher gets access to an image and does a "This Class" publish, one of these mcimage docs will not be created.

    d. if the user is a teacher and there is a network then a mcimages doc is searched for the legacyUrl and network. The first classPath from these matching mcimages docs is used. This would be the case of a published image by another teacher in the same network as the current teacher.

Note the supportKey, context_id, resource_link_id, and resource_url of the mcimages documents are not used. As far as I can tell these are stored to help track down the image.

## What publishSupport puts in an mcimages document

This is the other side of the getImageData. How a mcimages document is created or updated when the firebase function `publishSupport` is called.

Each publish results in a new mcsupports document. A `classPath` is constructed based on the context and auth information of the request. It will be `${root}/classes/${context.classHash}` where root varies depending on the auth information. This root is described in [./firebase-schema.md](./firebase-schema.md).

For every image url found in the published document:

1. the url is parsed to extract its `imageClassHash` and `imageKey`
2. the `imageClassPath` is constructed from the `classPath` by replacing the `classHash` in the path with the `imageClassHash`.
3. a mcimages document at `${firestoreRoot}/mcimages/${supportKey}_${imageKey}` is created, with:
  - **url** the image url without the class hash segment of the path this is referred to the `legacyUrl` in the code.
  - **classes** passed to the publishSupport as a parameter. These are the classes the support was published to.
  - **classPath** `${firebaseRoot}/classes/${class hash where the actual image data is located}`
  - **supportKey** id of the mcsupports firestore document
  - network info
  - **platform_id** portal identifier
  - **context_id** class hash where the actual image is stored
  - **resource_link_id** portal assignment or offering id of the published support.
  - **resource_url** should be url of the resource that was assigned in the portal in which the teacher was running when they published the support.

A key thing here is that just like mcsupports document, these mcimage documents are created on each publish. This is why there might be multiple matches for a particular network, or class. The same document could have been published more than once. Or the same image could be used in multiple documents that were published to the same network or class.

