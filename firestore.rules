// NOTE: to deploy only these rules run
// `npm run deploy:firestore:rules`

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // all documents are inaccessible unless allowed by rules below
    match /{document=**} {
      allow read, write: if false;
    }

    function exists(s) {
      return (s != null) && (s != "");
    }

    function isAuthed() {
      return request.auth != null;
    }

    // function hasClass() {
    //   return isAuthed() && request.auth.token.class_hash != null;
    // }

    // function hasClassHash(classHash) {
    //   return request.auth.token.class_hash == classHash;
    // }

    function hasRole(role) {
      return isAuthed() && request.auth.token.user_type == role;
    }

    function hasUserId() {
      return isAuthed() && request.auth.token.platform_user_id != null;
    }

    // function matchUserId(userId) {
    //   return hasUserId() && string(request.auth.token.platform_user_id) == userId;
    // }

    function matchFirebaseUserId(userId) {
      return isAuthed() && request.auth.uid == userId;
    }

    function isAuthedTeacher() {
      return hasUserId() && hasRole("teacher");
    }

    // uid of submitted document must match user's platform_user_id
    function requestMatchUserId() {
      return isAuthed() &&
        string(request.auth.token.platform_user_id) == request.resource.data.uid;
    }

    // user's platform_user_id must be in submitted document's list of teachers
    function requestMatchTeachers() {
      return isAuthed() &&
        string(request.auth.token.platform_user_id) in request.resource.data.teachers;
    }

    // uid of requested document must match user's platform_user_id
    function resourceMatchUserId() {
      return isAuthed() &&
        string(request.auth.token.platform_user_id) == resource.data.uid;
    }

    // user's platform_user_id must be in requested document's list of teachers
    function resourceMatchTeacher() {
      return isAuthed() &&
        string(request.auth.token.platform_user_id) in resource.data.teachers;
    }

    // user's class_hash must be in submitted document's list of classes
    function classInRequestClasses() {
      return isAuthed() && request.auth.token.class_hash in request.resource.data.classes;
    }

    // user's class_hash must be submitted document's context_id
    function classIsRequestContextId() {
      return isAuthed() && request.auth.token.class_hash == request.resource.data.context_id;
    }

    // user's class_hash must be in requested document's list of classes
    function classInResourceClasses() {
      return isAuthed() && request.auth.token.class_hash in resource.data.classes;
    }

    function isValidCurriculumCreateRequest() {
      return requestMatchUserId() &&
              request.resource.data.keys().hasAll(["uid", "unit", "problem", "section", "path", "network"]);
    }

    function isValidDocumentCreateRequest() {
      return requestMatchTeachers() && classIsRequestContextId() &&
              request.resource.data.keys().hasAll(["uid", "network", "type", "key", "createdAt"]);
    }

    function preservesReadOnlyDocumentFields() {
      let readOnlyFieldsSet = ["uid", "network", "type", "key", "createdAt"].toSet();
      let affectedFieldsSet = request.resource.data.diff(resource.data).affectedKeys();
      return !affectedFieldsSet.hasAny(readOnlyFieldsSet);
    }

    function isValidDocumentUpdateRequest() {
      return resourceMatchTeacher() && preservesReadOnlyDocumentFields();
    }

    function isValidSupportCreateRequest() {
      return requestMatchUserId() &&
              classInRequestClasses() &&
              classIsRequestContextId() &&
              (request.resource.data.content != null) &&
              (request.resource.data.type == "supportPublication");
    }

    function preservesReadOnlySupportFields() {
      let readOnlyFieldsSet = ["context_id", "createdAt", "network", "originDoc", "platform_id",
                                "problem", "resource_link_id", "resource_url", "type", "uid"].toSet();
      let affectedFieldsSet = request.resource.data.diff(resource.data).affectedKeys();
      return !affectedFieldsSet.hasAny(readOnlyFieldsSet);
    }

    function isValidSupportUpdateRequest() {
      return resourceMatchUserId() && preservesReadOnlySupportFields();
    }

    //
    // portal-authenticated secure access rules
    //
    match /authed/{portal} {
      allow read, write: if isAuthedTeacher();

      function getTeacherNetworks() {
        let platformUserId = string(request.auth.token.platform_user_id);
        return get(/databases/$(database)/documents/authed/$(portal)/users/$(platformUserId)).data.networks;
      }

      function resourceInTeacherNetworks() {
        return resource.data.network in getTeacherNetworks();
      }

      match /users/{userId} {
        // teachers can read their own user documents
        allow read: if isAuthedTeacher() && (string(request.auth.token.platform_user_id) == userId);
        // currently, only admins can write user information
        allow write: if false;
      }

      match /curriculum/{pathId} {
        // portal-authenticated teachers can create valid curriculum documents
        allow create: if isAuthedTeacher() && isValidCurriculumCreateRequest();
        // curriculum documents can't be updated or deleted
        allow update, delete: if false;
        // teachers can read their own curriculum documents or others in their network
        allow read: if isAuthedTeacher() && (resourceMatchUserId() || resourceInTeacherNetworks());

        function getCurriculumOwner() {
          return get(/databases/$(database)/documents/authed/$(portal)/curriculum/$(pathId)).data.uid;
        }

        function getCurriculumNetwork() {
          return get(/databases/$(database)/documents/authed/$(portal)/curriculum/$(pathId)).data.network;
        }

        function curriculumInTeacherNetworks() {
          let curriculumNetwork = getCurriculumNetwork();
          return exists(curriculumNetwork) && (curriculumNetwork in getTeacherNetworks());
        }

        function teacherIsCurriculumOwner() {
          let curriculumOwner = getCurriculumOwner();
          return string(request.auth.token.platform_user_id) == curriculumOwner;
        }

        function teacherCanAccessCurriculum() {
          return teacherIsCurriculumOwner() || curriculumInTeacherNetworks();
        }

        function isValidCommentCreateRequest() {
          return requestMatchUserId() &&
                  // comments network must match network of parent document
                  (request.resource.data.network == getCurriculumNetwork()) &&
                  request.resource.data.keys().hasAll(["name", "createdAt", "content", "network"]);
        }

        function preservesReadOnlyCommentFields() {
          let readOnlyFieldsSet = ["uid", "network", "createdAt", "tileId"].toSet();
          let affectedFieldsSet = request.resource.data.diff(resource.data).affectedKeys();
          return !affectedFieldsSet.hasAny(readOnlyFieldsSet);
        }

        function isValidCommentUpdateRequest() {
          return requestMatchUserId() && preservesReadOnlyCommentFields();
        }

        match /comments/{commentId} {
          // portal-authenticated teachers with access to the document can create valid comments
          allow create: if isAuthedTeacher() && teacherCanAccessCurriculum() && isValidCommentCreateRequest();
          // teachers can only update their own comments and only if they're valid
          allow update: if isAuthedTeacher() && teacherCanAccessCurriculum() && isValidCommentUpdateRequest();
          // teachers can only delete their own comments
          allow delete: if isAuthedTeacher() && teacherCanAccessCurriculum() && resourceMatchUserId();
          // only teachers that "own" the document can read the comments (for now)
          allow read: if isAuthedTeacher() && teacherCanAccessCurriculum();
        }
      }

      match /documents/{docId} {
        // portal-authenticated teachers can create valid documents
        allow create: if isAuthedTeacher() && isValidDocumentCreateRequest();
        // teachers can only update their own documents and only if they're valid
        allow update: if isAuthedTeacher() && isValidDocumentUpdateRequest();
        // teachers can only delete their own documents
        allow delete: if isAuthedTeacher() && resourceMatchUserId();
        // teachers can read their own documents or other documents in their network
        allow read: if isAuthedTeacher() && (resourceMatchTeacher() || resourceInTeacherNetworks());

        function getDocumentTeachers() {
          return get(/databases/$(database)/documents/authed/$(portal)/documents/$(docId)).data.teachers;
        }

        function getDocumentNetwork() {
          return get(/databases/$(database)/documents/authed/$(portal)/documents/$(docId)).data.network;
        }

        function teacherInDocumentTeachers() {
          return isAuthedTeacher() && (request.auth.uid in getDocumentTeachers());
        }

        function documentInTeacherNetworks() {
          let docNetwork = getDocumentNetwork();
          return exists(docNetwork) && (docNetwork in getTeacherNetworks());
        }

        function teacherCanAccessDocument() {
          return teacherInDocumentTeachers() || documentInTeacherNetworks();
        }

        function isValidCommentCreateRequest() {
          return requestMatchUserId() &&
                  // comments network must match network of parent document
                  (request.resource.data.network == getDocumentNetwork()) &&
                  request.resource.data.keys().hasAll(["name", "createdAt", "content"]);
        }

        function preservesReadOnlyCommentFields() {
          let readOnlyFieldsSet = ["uid", "network", "createdAt", "tileId"].toSet();
          let affectedFieldsSet = request.resource.data.diff(resource.data).affectedKeys();
          return !affectedFieldsSet.hasAny(readOnlyFieldsSet);
        }

        function isValidCommentUpdateRequest() {
          return requestMatchUserId() && preservesReadOnlyCommentFields();
        }

        match /comments/{commentId} {
          // portal-authenticated teachers with access to the document can create valid comments
          allow create: if isAuthedTeacher() && teacherCanAccessDocument() && isValidCommentCreateRequest();
          // teachers can only update their own comments and only if they're valid
          allow update: if isAuthedTeacher() && teacherCanAccessDocument() && isValidCommentUpdateRequest();
          // teachers can only delete their own comments
          allow delete: if isAuthedTeacher() && teacherCanAccessDocument() && resourceMatchUserId();
          // only teachers that "own" the document can read the comments (for now)
          allow read: if isAuthedTeacher() && teacherCanAccessDocument();
        }
      }

      match /mcsupports/{docId} {
        // portal-authenticated teachers can create valid supports
        allow create: if isAuthedTeacher() && isValidSupportCreateRequest();
        // teachers can only update their own supports and only if they're valid
        allow update: if isAuthedTeacher() && isValidSupportUpdateRequest();
        // teachers can only delete their own supports
        allow delete: if isAuthedTeacher() && resourceMatchUserId();
        // teachers and students in appropriate classes can read supports
        allow read: if resourceMatchUserId() || classInResourceClasses();
      }
    }

    //
    // non-portal-authenticated/dev/demo/qa/test rules
    //
    match /demo/{demoName}/{restOfPath=**} {
      allow read, write: if isAuthed();
    }

    match /dev/{userId}/{restOfPath=**} {
      allow read: if isAuthed();
      // users can only write to their own folders
      allow write: if matchFirebaseUserId(userId);
    }

    match /qa/{userId}/{restOfPath=**} {
      allow read: if isAuthed();
      // users can only write to their own folders
      allow write: if matchFirebaseUserId(userId);
    }

    match /test/{userId}/{restOfPath=**} {
      allow read: if isAuthed();
      // users can only write to their own folders
      allow write: if matchFirebaseUserId(userId);
    }

  }
}
